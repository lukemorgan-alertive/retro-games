import argparse
import csv
import getpass
import re
import sqlite3
from dataclasses import dataclass
from datetime import date, datetime
from pathlib import Path
from typing import Optional, Iterable

import bcrypt

ALLOWED_CONDITIONS = {"mint", "vgc", "gc", "used"}
PROJECT_ROOT = Path(__file__).resolve().parent.parent
DEFAULT_DB_PATH = PROJECT_ROOT / "retro_games.db"

@dataclass
class Game:
    """
    Represents a retro game in the catalog.
    
    Attributes:
        title (str): Game title.
        release_year (int): Year the game was released.
        platform (str): Gaming platform (e.g., SNES, PS1, NES).
        date_acquired (str): Date acquired in ISO format (YYYY-MM-DD).
        condition (Optional[str]): Condition of the game (mint, vgc, gc, used).
    """
    title: str
    release_year: int
    platform: str
    date_acquired: str
    condition: Optional[str] = None


@dataclass
class AdminUser:
    """
    Represents an admin user for the system.
    
    Attributes:
        id (int): Unique identifier (auto-generated by database).
        username (str): Unique username for the admin (required).
        created_at (str): Timestamp when the admin was created (ISO format).
        updated_at (str): Timestamp when the admin was last updated (ISO format).
        firstname (Optional[str]): Admin's first name (nullable).
        lastname (Optional[str]): Admin's last name (nullable).
    
    Note:
        password_hash is intentionally not stored in this dataclass to prevent
        accidental exposure. Passwords are handled separately during creation.
    """
    id: int
    username: str
    created_at: str
    updated_at: str
    firstname: Optional[str] = None
    lastname: Optional[str] = None


def get_connection(db_path: Path) -> sqlite3.Connection:
    """
    Create a database connection with foreign key enforcement enabled.
    
    Args:
        db_path (Path): Path to the SQLite database file.
    
    Returns:
        sqlite3.Connection: Database connection object.
    """
    conn = sqlite3.connect(db_path)
    conn.execute("PRAGMA foreign_keys = ON")
    return conn


def init_db(db_path: Path) -> None:
    """
    Initialize the database schema.
    
    Creates the games and admin_users tables if they don't exist. Safe to call
    multiple times as it uses CREATE TABLE IF NOT EXISTS (idempotent operation).
    
    Args:
        db_path (Path): Path to the SQLite database file.
    
    ✓ SECURITY: Database initialization uses static DDL with no user input.
      CHECK constraint validates condition values at the database level,
      providing defense-in-depth alongside application-level validation.
    """
    conn = get_connection(db_path)
    try:
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS games (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                release_year INTEGER NOT NULL,
                platform TEXT NOT NULL,
                date_acquired TEXT NOT NULL,
                condition TEXT CHECK (
                    condition IN ('mint','vgc','gc','used')
                )
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS admin_users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                firstname TEXT,
                lastname TEXT,
                password_hash TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )
            """
        )
        conn.commit()
    finally:
        conn.close()


def validate_date(value: str) -> str:
    """
    Validate that a string is a valid ISO date (YYYY-MM-DD).
    
    Args:
        value (str): Date string to validate.
    
    Returns:
        str: The validated date string.
    
    Raises:
        argparse.ArgumentTypeError: If date format is invalid.
    """
    try:
        date.fromisoformat(value)
        return value
    except Exception:
        raise argparse.ArgumentTypeError("date must be in YYYY-MM-DD format")


def validate_condition(value: Optional[str]) -> Optional[str]:
    """
    Validate game condition against allowed values.
    
    Args:
        value (Optional[str]): Condition value to validate.
    
    Returns:
        Optional[str]: Normalized condition (lowercase) or None if empty.
    
    Raises:
        argparse.ArgumentTypeError: If condition is not in allowed set.
    
    Edge cases handled:
        - None values return None
        - Empty strings return None
        - Whitespace-only strings return None
        - Case-insensitive matching (normalized to lowercase)
    """
    if value is None or value == "":
        return None
    v = value.strip().lower()
    if not v:  # whitespace-only string edge case
        return None
    if v not in ALLOWED_CONDITIONS:
        raise argparse.ArgumentTypeError(
            f"condition must be one of {sorted(ALLOWED_CONDITIONS)}"
        )
    return v


def validate_username(value: str) -> str:
    """
    Validate admin username format.
    
    Args:
        value (str): Username to validate.
    
    Returns:
        str: The validated username (stripped of leading/trailing whitespace).
    
    Raises:
        argparse.ArgumentTypeError: If username format is invalid.
    
    Edge cases handled:
        - Strips leading/trailing whitespace
        - Rejects empty or whitespace-only strings
        - Enforces length limits (3-50 characters)
        - Allows alphanumeric characters, underscores, and hyphens only
    
    ✓ SECURITY: Username validation prevents injection of special characters
      that could be problematic in various contexts (SQL, shell, etc.).
    """
    if value is None:
        raise argparse.ArgumentTypeError("username is required")
    v = value.strip()
    if not v:
        raise argparse.ArgumentTypeError("username cannot be empty")
    if len(v) < 3:
        raise argparse.ArgumentTypeError("username must be at least 3 characters")
    if len(v) > 50:
        raise argparse.ArgumentTypeError("username must be at most 50 characters")
    if not re.match(r'^[a-zA-Z0-9_-]+$', v):
        raise argparse.ArgumentTypeError(
            "username must contain only alphanumeric characters, underscores, and hyphens"
        )
    return v


def validate_password(password: str) -> str:
    """
    Validate password strength requirements.
    
    Args:
        password (str): The password to validate.
    
    Returns:
        str: The validated password.
    
    Raises:
        ValueError: If password does not meet strength requirements.
    
    Password Requirements:
        - Minimum length of 12 characters
        - Must contain at least one letter (a-z or A-Z)
        - Must contain at least one number (0-9)
        - Must contain at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)
    
    ✓ SECURITY: Enforces strong password policy to protect admin accounts.
      Weak passwords are a common attack vector; these requirements help
      ensure passwords are resistant to dictionary and brute-force attacks.
    """
    if not password:
        raise ValueError("Password cannot be empty")
    
    if len(password) < 12:
        raise ValueError("Password must be at least 12 characters long")
    
    has_letter = bool(re.search(r'[a-zA-Z]', password))
    has_number = bool(re.search(r'[0-9]', password))
    has_special = bool(re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password))
    
    missing = []
    if not has_letter:
        missing.append("letter")
    if not has_number:
        missing.append("number")
    if not has_special:
        missing.append("special character (!@#$%^&*()_+-=[]{}|;:,.<>?)")
    
    if missing:
        raise ValueError(f"Password must contain at least one: {', '.join(missing)}")
    
    return password


def hash_password(password: str) -> str:
    """
    Hash a password using bcrypt.
    
    Args:
        password (str): The plaintext password to hash.
    
    Returns:
        str: The bcrypt-hashed password as a string.
    
    ✓ SECURITY: Uses bcrypt which automatically generates a unique salt for each
      password and uses a computationally expensive algorithm to resist brute-force
      attacks. The salt is embedded in the returned hash string.
    """
    password_bytes = password.encode('utf-8')
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password_bytes, salt)
    return hashed.decode('utf-8')


def verify_password(password: str, password_hash: str) -> bool:
    """
    Verify a password against a bcrypt hash.
    
    Args:
        password (str): The plaintext password to verify.
        password_hash (str): The bcrypt hash to verify against.
    
    Returns:
        bool: True if the password matches, False otherwise.
    
    ✓ SECURITY: Uses bcrypt's constant-time comparison to prevent timing attacks.
    """
    password_bytes = password.encode('utf-8')
    hash_bytes = password_hash.encode('utf-8')
    return bcrypt.checkpw(password_bytes, hash_bytes)


def add_game(db_path: Path, game: Game) -> None:
    """
    Add a new game to the database.
    
    Args:
        db_path (Path): Path to the SQLite database file.
        game (Game): Game object containing all required fields.
    
    Note:
        SQLite doesn't support true ENUM; we enforce via CHECK and app-side validation.
    
    ✓ SECURITY: Parameterized queries with ? placeholders prevent SQL injection.
      All user input (title, platform, condition) is passed separately from the
      SQL statement, preventing malicious SQL code injection through these fields.
    
    Edge cases handled:
        - Validates title/platform length limits (max 500 chars)
        - Validates year range (1970-2030)
        - Handles database write failures with proper error reporting
        - Ensures connection cleanup via finally block
    
    Raises:
        ValueError: If validation fails on input fields.
        sqlite3.Error: If database operation fails.
    """
    if len(game.title) > 500:
        raise ValueError("Title exceeds maximum length of 500 characters")
    if len(game.platform) > 100:
        raise ValueError("Platform exceeds maximum length of 100 characters")
    if game.release_year < 1970 or game.release_year > 2030:
        raise ValueError("Release year must be between 1970 and 2030")
    
    conn = get_connection(db_path)
    try:
        conn.execute(
            """
            INSERT INTO games (title, release_year, platform, date_acquired, condition)
            VALUES (?, ?, ?, ?, ?)
            """,
            (
                game.title,
                game.release_year,
                game.platform,
                game.date_acquired,
                game.condition,
            ),
        )
        conn.commit()
    except sqlite3.Error as e:
        raise sqlite3.Error(f"Database error while adding game: {e}")
    finally:
        conn.close()


def import_csv(db_path: Path, csv_path: Path) -> int:
    """
    Import games from a CSV file into the database.
    
    Args:
        db_path (Path): Path to the SQLite database file.
        csv_path (Path): Path to the CSV file to import.
    
    Returns:
        int: Number of games successfully imported.
    
    Note:
        Invalid rows (missing data, bad format) are silently skipped.
        Required CSV columns: title, release_year, platform, date_acquired
        Optional CSV column: condition
    
    Edge cases handled:
        - Missing required columns raises ValueError
        - Empty/whitespace-only title or platform skipped
        - Invalid year formats (non-numeric) skipped
        - Invalid date formats (non-ISO) skipped
        - Invalid condition values normalized to None
        - File encoding issues handled via utf-8 with error handling
        - Large files processed row-by-row (memory efficient)
    
    Raises:
        ValueError: If CSV is missing required columns.
        FileNotFoundError: If CSV file doesn't exist.
        PermissionError: If file cannot be read.
    """
    if not csv_path.exists():
        raise FileNotFoundError(f"CSV file not found: {csv_path}")
    
    count = 0
    with csv_path.open(newline="", encoding="utf-8", errors="replace") as f:
        reader = csv.DictReader(f)
        required_cols = {"title", "release_year", "platform", "date_acquired"}
        missing = required_cols - set(reader.fieldnames or [])
        if missing:
            raise ValueError(
                f"CSV missing required columns: {', '.join(sorted(missing))}"
            )
        for row in reader:
            title = (row.get("title") or "").strip()
            platform = (row.get("platform") or "").strip()
            if not title or not platform:
                # Skip incomplete rows
                continue
            try:
                release_year = int((row.get("release_year") or "").strip())
            except ValueError:
                # Skip invalid year
                continue
            try:
                date_acquired = validate_date((row.get("date_acquired") or "").strip())
            except argparse.ArgumentTypeError:
                # Skip invalid dates
                continue
            condition = row.get("condition")
            try:
                condition = validate_condition(condition)
            except argparse.ArgumentTypeError:
                # Skip invalid condition values
                condition = None

            add_game(db_path, Game(title, release_year, platform, date_acquired, condition))
            count += 1
    return count


def list_games(db_path: Path) -> Iterable[Game]:
    """
    Retrieve all games from the database.
    
    Args:
        db_path (Path): Path to the SQLite database file.
    
    Yields:
        Game: Game objects ordered by title.
    
    ✓ SECURITY: No user input is interpolated in this query. The SQL statement
      is static and contains no user-controlled data, preventing SQL injection.
    """
    conn = get_connection(db_path)
    try:
        cur = conn.execute(
            "SELECT title, release_year, platform, date_acquired, condition FROM games ORDER BY title"
        )
        for (title, yr, platform, acquired, cond) in cur.fetchall():
            yield Game(title=title, release_year=yr, platform=platform, date_acquired=acquired, condition=cond)
    finally:
        conn.close()


def export_csv(db_path: Path, csv_path: Path) -> int:
    """
    Export all games to a CSV file.
    
    Args:
        db_path (Path): Path to the SQLite database file.
        csv_path (Path): Path where CSV file will be written.
    
    Returns:
        int: Number of games exported.
    
    ✓ SECURITY: No user input is interpolated in this query. The SQL statement
      is static and contains no user-controlled data, preventing SQL injection.
    """
    conn = get_connection(db_path)
    try:
        cur = conn.execute(
            "SELECT title, release_year, platform, date_acquired, condition FROM games ORDER BY title"
        )
        rows = cur.fetchall()
        with csv_path.open("w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["title", "release_year", "platform", "date_acquired", "condition"])
            for (title, yr, platform, acquired, cond) in rows:
                writer.writerow([title, yr, platform, acquired, cond or ""])
        return len(rows)
    finally:
        conn.close()


def add_admin_user(db_path: Path, username: str, password: str,
                   firstname: Optional[str] = None,
                   lastname: Optional[str] = None) -> AdminUser:
    """
    Add a new admin user to the database.
    
    Args:
        db_path (Path): Path to the SQLite database file.
        username (str): Unique username for the admin.
        password (str): Plaintext password (will be hashed before storage).
        firstname (Optional[str]): Admin's first name.
        lastname (Optional[str]): Admin's last name.
    
    Returns:
        AdminUser: The created admin user object (without password_hash).
    
    ✓ SECURITY: Parameterized queries with ? placeholders prevent SQL injection.
      Password is hashed using bcrypt before storage - plaintext password is
      never stored in the database. Timestamps are generated server-side.
    
    Edge cases handled:
        - Username uniqueness enforced at database level (UNIQUE constraint)
        - Validates username format before insertion
        - Handles database write failures with proper error reporting
        - Ensures connection cleanup via finally block
    
    Raises:
        argparse.ArgumentTypeError: If username validation fails.
        sqlite3.IntegrityError: If username already exists.
        sqlite3.Error: If database operation fails.
    """
    # Validate username format
    validated_username = validate_username(username)
    
    # Hash the password
    password_hash = hash_password(password)
    
    # Generate timestamps
    now = datetime.utcnow().isoformat() + "Z"
    
    conn = get_connection(db_path)
    try:
        cursor = conn.execute(
            """
            INSERT INTO admin_users (username, firstname, lastname, password_hash, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?)
            """,
            (validated_username, firstname, lastname, password_hash, now, now),
        )
        conn.commit()
        
        # Get the auto-generated id
        admin_id = cursor.lastrowid
        if admin_id is None:
            raise sqlite3.Error("Failed to retrieve admin user ID after insertion")
        
        return AdminUser(
            id=admin_id,
            username=validated_username,
            created_at=now,
            updated_at=now,
            firstname=firstname,
            lastname=lastname
        )
    except sqlite3.IntegrityError as e:
        if "UNIQUE constraint failed" in str(e):
            raise sqlite3.IntegrityError(f"Username '{validated_username}' already exists")
        raise
    except sqlite3.Error as e:
        raise sqlite3.Error(f"Database error while adding admin user: {e}")
    finally:
        conn.close()


def remove_admin_user(db_path: Path, username: str) -> bool:
    """
    Remove an admin user from the database by username.
    
    Args:
        db_path (Path): Path to the SQLite database file.
        username (str): Username of the admin to remove.
    
    Returns:
        bool: True if user was removed, False if user was not found.
    
    ✓ SECURITY: Parameterized queries with ? placeholders prevent SQL injection.
      Username is passed separately from the SQL statement.
    
    Edge cases handled:
        - Returns False if user doesn't exist (no error raised)
        - Handles database errors with proper reporting
        - Ensures connection cleanup via finally block
    
    Raises:
        sqlite3.Error: If database operation fails.
    """
    conn = get_connection(db_path)
    try:
        cursor = conn.execute(
            "DELETE FROM admin_users WHERE username = ?",
            (username,)
        )
        conn.commit()
        return cursor.rowcount > 0
    except sqlite3.Error as e:
        raise sqlite3.Error(f"Database error while removing admin user: {e}")
    finally:
        conn.close()


def list_admin_users(db_path: Path) -> Iterable[AdminUser]:
    """
    Retrieve all admin users from the database.
    
    Args:
        db_path (Path): Path to the SQLite database file.
    
    Yields:
        AdminUser: Admin user objects ordered by username.
                   Note: password_hash is NOT included for security.
    
    ✓ SECURITY: No user input is interpolated in this query. The SQL statement
      is static and contains no user-controlled data, preventing SQL injection.
      Password hashes are intentionally excluded from the result to prevent
      accidental exposure.
    """
    conn = get_connection(db_path)
    try:
        cur = conn.execute(
            """
            SELECT id, username, firstname, lastname, created_at, updated_at
            FROM admin_users
            ORDER BY username
            """
        )
        for (admin_id, username, firstname, lastname, created_at, updated_at) in cur.fetchall():
            yield AdminUser(
                id=admin_id,
                username=username,
                created_at=created_at,
                updated_at=updated_at,
                firstname=firstname,
                lastname=lastname
            )
    finally:
        conn.close()


def build_parser() -> argparse.ArgumentParser:
    """
    Build the command-line argument parser.
    
    Returns:
        argparse.ArgumentParser: Configured parser with all subcommands.
    
    Commands:
        - init: Initialize database schema
        - add: Add a single game
        - import: Import games from CSV
        - list: Display all games
        - export: Export games to CSV
        - admin-add: Add a new admin user
        - admin-remove: Remove an admin user
        - admin-list: List all admin users
    """
    parser = argparse.ArgumentParser(
        description="Retro games catalog CLI (SQLite-backed)"
    )
    parser.add_argument(
        "--db",
        type=Path,
        default=DEFAULT_DB_PATH,
        help=f"Path to SQLite database file (default: {DEFAULT_DB_PATH})",
    )

    sub = parser.add_subparsers(dest="command", required=True)

    p_init = sub.add_parser("init", help="Initialize the database schema")

    p_add = sub.add_parser("add", help="Add a single game entry")
    p_add.add_argument("title", help="Game title")
    p_add.add_argument("release_year", type=int, help="Release year (e.g., 1998)")
    p_add.add_argument("platform", help="Platform (e.g., SNES, PS1)")
    p_add.add_argument(
        "date_acquired",
        type=validate_date,
        help="Date acquired (YYYY-MM-DD)",
    )
    p_add.add_argument(
        "--condition",
        type=validate_condition,
        help="Condition (mint|vgc|gc|used); optional",
    )

    p_import = sub.add_parser("import", help="Import games from a CSV file")
    p_import.add_argument("csv", type=Path, help="Path to CSV file")

    p_list = sub.add_parser("list", help="List games in the database")

    p_export = sub.add_parser("export", help="Export games to a CSV file")
    p_export.add_argument("csv", type=Path, help="Destination CSV file path")

    # Admin user management commands
    p_admin_add = sub.add_parser("admin-add", help="Add a new admin user")
    p_admin_add.add_argument("username", type=validate_username, help="Admin username (3-50 alphanumeric chars, underscores, hyphens)")
    p_admin_add.add_argument("--firstname", help="Admin's first name (optional)")
    p_admin_add.add_argument("--lastname", help="Admin's last name (optional)")

    p_admin_remove = sub.add_parser("admin-remove", help="Remove an admin user")
    p_admin_remove.add_argument("username", help="Username of admin to remove")
    p_admin_remove.add_argument("--yes", "-y", action="store_true", help="Skip confirmation prompt")

    p_admin_list = sub.add_parser("admin-list", help="List all admin users")

    return parser


def main(argv: Optional[Iterable[str]] = None) -> None:
    """
    Main entry point for the CLI application.
    
    Args:
        argv (Optional[Iterable[str]]): Command-line arguments. If None, uses sys.argv.
    
    Handles all CLI commands: init, add, import, list, export, admin-add,
    admin-remove, admin-list.
    """
    parser = build_parser()
    args = parser.parse_args(argv)

    db_path: Path = args.db
    if args.command == "init":
        init_db(db_path)
        print(f"Initialized database at {db_path}")
    elif args.command == "add":
        init_db(db_path)  # safe if already exists
        game = Game(
            title=args.title,
            release_year=args.release_year,
            platform=args.platform,
            date_acquired=args.date_acquired,
            condition=args.condition,
        )
        add_game(db_path, game)
        print("Added:", game)
    elif args.command == "import":
        init_db(db_path)
        count = import_csv(db_path, args.csv)
        print(f"Imported {count} rows from {args.csv}")
    elif args.command == "list":
        init_db(db_path)
        rows = list(list_games(db_path))
        if not rows:
            print("No games found.")
        else:
            headers = ["Title", "Year", "Platform", "Acquired", "Condition"]
            data = [
                [g.title, str(g.release_year), g.platform, g.date_acquired, g.condition or ""]
                for g in rows
            ]
            widths = [len(h) for h in headers]
            for row in data:
                for i, cell in enumerate(row):
                    w = len(str(cell))
                    if w > widths[i]:
                        widths[i] = w
            header_line = " | ".join(h.ljust(widths[i]) for i, h in enumerate(headers))
            sep_line = "-+-".join("-" * widths[i] for i in range(len(headers)))
            row_lines = [
                " | ".join(str(cell).ljust(widths[i]) for i, cell in enumerate(row))
                for row in data
            ]
            print(header_line)
            print(sep_line)
            for line in row_lines:
                print(line)
    elif args.command == "export":
        init_db(db_path)
        count = export_csv(db_path, args.csv)
        print(f"Exported {count} rows to {args.csv}")
    elif args.command == "admin-add":
        init_db(db_path)
        # Display password requirements
        print("Password requirements:")
        print("  - Minimum 12 characters")
        print("  - Must contain at least one letter (a-z or A-Z)")
        print("  - Must contain at least one number (0-9)")
        print("  - Must contain at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)")
        print()
        
        # Prompt for password securely (hidden input)
        password = getpass.getpass("Enter password for admin user: ")
        
        # Validate password strength
        try:
            validate_password(password)
        except ValueError as e:
            print(f"Error: {e}")
            return
        
        password_confirm = getpass.getpass("Confirm password: ")
        if password != password_confirm:
            print("Error: Passwords do not match.")
            return
        
        try:
            admin = add_admin_user(
                db_path,
                username=args.username,
                password=password,
                firstname=args.firstname,
                lastname=args.lastname
            )
            print(f"Added admin user: {admin.username} (ID: {admin.id})")
            if admin.firstname or admin.lastname:
                name_parts = [p for p in [admin.firstname, admin.lastname] if p]
                print(f"  Name: {' '.join(name_parts)}")
            print(f"  Created: {admin.created_at}")
        except sqlite3.IntegrityError as e:
            print(f"Error: {e}")
    elif args.command == "admin-remove":
        init_db(db_path)
        # Confirm removal unless --yes flag is provided
        if not args.yes:
            confirm = input(f"Are you sure you want to remove admin '{args.username}'? [y/N]: ")
            if confirm.lower() not in ('y', 'yes'):
                print("Aborted.")
                return
        removed = remove_admin_user(db_path, args.username)
        if removed:
            print(f"Removed admin user: {args.username}")
        else:
            print(f"Admin user not found: {args.username}")
    elif args.command == "admin-list":
        init_db(db_path)
        admins = list(list_admin_users(db_path))
        if not admins:
            print("No admin users found.")
        else:
            headers = ["ID", "Username", "First Name", "Last Name", "Created At", "Updated At"]
            data = [
                [
                    str(a.id),
                    a.username,
                    a.firstname or "",
                    a.lastname or "",
                    a.created_at or "",
                    a.updated_at or ""
                ]
                for a in admins
            ]
            widths = [len(h) for h in headers]
            for row in data:
                for i, cell in enumerate(row):
                    w = len(str(cell))
                    if w > widths[i]:
                        widths[i] = w
            header_line = " | ".join(h.ljust(widths[i]) for i, h in enumerate(headers))
            sep_line = "-+-".join("-" * widths[i] for i in range(len(headers)))
            row_lines = [
                " | ".join(str(cell).ljust(widths[i]) for i, cell in enumerate(row))
                for row in data
            ]
            print(header_line)
            print(sep_line)
            for line in row_lines:
                print(line)


if __name__ == "__main__":
    main()